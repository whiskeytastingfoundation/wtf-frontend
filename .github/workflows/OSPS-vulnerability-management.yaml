name: OSPS Vulnerability Management Checks

on:
  schedule:
    - cron: '0 0 * * 0'  # Run weekly on Sunday at midnight
  workflow_dispatch:      # Allow manual triggering
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/osps-vm.yml'

jobs:
  vulnerability-management-checks:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Needed for attestation signing

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up GitHub CLI
        run: |
          gh --version || (
            type -p curl >/dev/null || sudo apt install curl -y
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
            && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
            && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
            && sudo apt update \
            && sudo apt install gh -y
          )
        shell: bash

      - name: Setup attestation tools
        run: |
          mkdir -p attestations
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq
        shell: bash

      - name: Check Vulnerability Reporting Policy (OSPS-VM-01)
        id: vm-01-check
        run: |
          #!/bin/bash
          # Check if the project has a policy for coordinated vulnerability reporting

          echo "Checking for coordinated vulnerability reporting policy..."

          # Check for SECURITY.md file in different locations
          SECURITY_FILES=(
              "SECURITY.md"
              "security.md"
              "docs/SECURITY.md"
              "docs/security.md"
              ".github/SECURITY.md"
              ".github/security.md"
          )

          POLICY_FOUND=0
          TIMEFRAME_FOUND=0

          for FILE_PATH in "${SECURITY_FILES[@]}"; do
              if [ -f "$FILE_PATH" ]; then
                  echo "✅ Found security policy file: $FILE_PATH"
                  POLICY_FOUND=1
                  
                  # Read the file and check for timeframe information
                  CONTENT=$(cat "$FILE_PATH" | tr '[:upper:]' '[:lower:]')
                  
                  # Look for common phrases indicating a response timeframe
                  if [[ "$CONTENT" =~ respond.*within.*([0-9]+).*(hour|day|week|business.day) ]] || 
                     [[ "$CONTENT" =~ response.*time.*of.*([0-9]+).*(hour|day|week|business.day) ]] || 
                     [[ "$CONTENT" =~ ([0-9]+)(-|to)([0-9]+).*(hour|day|week|business.day).*response ]] || 
                     [[ "$CONTENT" =~ timeframe.*for.*response.*([0-9]+).*(hour|day|week|business.day) ]] || 
                     [[ "$CONTENT" =~ acknowledge.*within.*([0-9]+).*(hour|day|week|business.day) ]]; then
                      echo "✅ Found response timeframe in $FILE_PATH"
                      TIMEFRAME_FOUND=1
                  fi
              fi
          done

          # Additionally, search for CODE_OF_CONDUCT.md which might contain vulnerability reporting info
          COC_FILES=(
              "CODE_OF_CONDUCT.md"
              "code_of_conduct.md"
              "docs/CODE_OF_CONDUCT.md"
              ".github/CODE_OF_CONDUCT.md"
          )

          if [ $POLICY_FOUND -eq 0 ]; then
              for FILE_PATH in "${COC_FILES[@]}"; do
                  if [ -f "$FILE_PATH" ]; then
                      CONTENT=$(cat "$FILE_PATH" | tr '[:upper:]' '[:lower:]')
                      if [[ "$CONTENT" =~ vulnerability ]] && [[ "$CONTENT" =~ report ]]; then
                          echo "⚠️ Found vulnerability reporting information in $FILE_PATH, but should be in SECURITY.md"
                          POLICY_FOUND=1
                      fi
                  fi
              done
          fi

          # Also check the README for security information (less ideal location)
          README_FILES=(
              "README.md"
              "readme.md"
              "README"
              "readme"
          )

          if [ $POLICY_FOUND -eq 0 ]; then
              for FILE_PATH in "${README_FILES[@]}"; do
                  if [ -f "$FILE_PATH" ]; then
                      CONTENT=$(cat "$FILE_PATH" | tr '[:upper:]' '[:lower:]')
                      if [[ "$CONTENT" =~ security ]] || [[ "$CONTENT" =~ vulnerability ]] && [[ "$CONTENT" =~ report ]]; then
                          echo "⚠️ Found vulnerability reporting information in $FILE_PATH, but should be in SECURITY.md"
                          POLICY_FOUND=1
                          
                          # Check for timeframe if not already found
                          if [ $TIMEFRAME_FOUND -eq 0 ]; then
                              if [[ "$CONTENT" =~ respond.*within.*([0-9]+).*(hour|day|week|business.day) ]] || 
                                 [[ "$CONTENT" =~ response.*time.*of.*([0-9]+).*(hour|day|week|business.day) ]] || 
                                 [[ "$CONTENT" =~ ([0-9]+)(-|to)([0-9]+).*(hour|day|week|business.day).*response ]] || 
                                 [[ "$CONTENT" =~ timeframe.*for.*response.*([0-9]+).*(hour|day|week|business.day) ]] || 
                                 [[ "$CONTENT" =~ acknowledge.*within.*([0-9]+).*(hour|day|week|business.day) ]]; then
                                  echo "✅ Found response timeframe in $FILE_PATH"
                                  TIMEFRAME_FOUND=1
                              fi
                          fi
                      fi
                  fi
              done
          fi

          # Report findings
          if [ $POLICY_FOUND -eq 0 ]; then
              echo "❌ No coordinated vulnerability reporting policy found"
              echo "result=1" >> $GITHUB_OUTPUT
              exit 1
          elif [ $TIMEFRAME_FOUND -eq 0 ]; then
              echo "❌ Vulnerability policy found, but no clear response timeframe specified"
              echo "result=1" >> $GITHUB_OUTPUT
              exit 1
          else
              echo "✅ Coordinated vulnerability reporting policy with timeframe found"
              echo "result=0" >> $GITHUB_OUTPUT
              exit 0
          fi
        shell: bash

      - name: Generate attestation for VM-01
        run: |
          RESULT=${{ steps.vm-01-check.outputs.result }}
          RESULT_TEXT=$([ "$RESULT" == "0" ] && echo "pass" || echo "fail")
          
          cat > attestations/osps-vm-01-attestation.json << EOF
          {
            "subject": {
              "name": "OSPS-VM-01",
              "digest": {
                "sha256": "${{ github.sha }}"
              }
            },
            "predicate": {
              "type": "https://github.com/osps/attestation/v1",
              "control": "OSPS-VM-01",
              "title": "The project documentation MUST include a policy for coordinated vulnerability reporting, with a clear timeframe for response.",
              "result": "$RESULT_TEXT",
              "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
              "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
          }
          EOF
        shell: bash

      - name: Check Vulnerability Reporting Contacts (OSPS-VM-02)
        id: vm-02-check
        run: |
          #!/bin/bash
          # Check if the project publishes contacts for reporting vulnerabilities.
          
          echo "Checking for security contacts..."
          
          # Files to check for security contacts
          SECURITY_FILES=(
              "SECURITY.md"
              "security.md"
              "docs/SECURITY.md"
              "docs/security.md"
              ".github/SECURITY.md"
              ".github/security.md"
              "README.md"
              "readme.md"
          )
          
          CONTACTS_FOUND=0
          
          for FILE_PATH in "${SECURITY_FILES[@]}"; do
              if [ -f "$FILE_PATH" ]; then
                  # Read file content
                  CONTENT=$(cat "$FILE_PATH")
                  
                  # Check for email patterns or common contact info
                  if [[ "$CONTENT" =~ [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,} ]] || 
                     [[ "$CONTENT" =~ "security@" ]] || 
                     [[ "$CONTENT" =~ "vulnerabilit" && "$CONTENT" =~ "report" && "$CONTENT" =~ "contact" ]]; then
                      echo "✅ Found security contacts in $FILE_PATH"
                      CONTACTS_FOUND=1
                      break
                  fi
              fi
          done
          
          # Check for security.txt file - a standard location for security contact info
          SECURITY_TXT_FILES=(
              ".well-known/security.txt"
              ".github/security.txt"
              "security.txt"
          )
          
          for FILE_PATH in "${SECURITY_TXT_FILES[@]}"; do
              if [ -f "$FILE_PATH" ]; then
                  echo "✅ Found security.txt file at $FILE_PATH"
                  CONTACTS_FOUND=1
                  break
              fi
          done
          
          # Report findings
          if [ $CONTACTS_FOUND -eq 0 ]; then
              echo "❌ No security contacts published"
              echo "result=1" >> $GITHUB_OUTPUT
              exit 1
          else
              echo "✅ Security contacts published"
              echo "result=0" >> $GITHUB_OUTPUT
              exit 0
          fi
        shell: bash

      - name: Generate attestation for VM-02
        run: |
          RESULT=${{ steps.vm-02-check.outputs.result }}
          RESULT_TEXT=$([ "$RESULT" == "0" ] && echo "pass" || echo "fail")
          
          cat > attestations/osps-vm-02-attestation.json << EOF
          {
            "subject": {
              "name": "OSPS-VM-02",
              "digest": {
                "sha256": "${{ github.sha }}"
              }
            },
            "predicate": {
              "type": "https://github.com/osps/attestation/v1",
              "control": "OSPS-VM-02",
              "title": "The project MUST publish contacts and process for reporting vulnerabilities.",
              "result": "$RESULT_TEXT", 
              "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
              "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
          }
          EOF
        shell: bash

      - name: Check Private Vulnerability Reporting (OSPS-VM-03)
        id: vm-03-check
        run: |
          #!/bin/bash
          # Check if the project provides a means for reporting security vulnerabilities privately.
          
          echo "Checking for private vulnerability reporting mechanism..."
          
          # Check if GitHub private vulnerability reporting is enabled
          PRIVATE_REPORTING_ENABLED=$(gh api "repos/${GITHUB_REPOSITORY}/private-vulnerability-reporting" --jq '.enabled' 2>/dev/null)
          if [[ "$PRIVATE_REPORTING_ENABLED" == "true" ]]; then
              echo "✅ GitHub private vulnerability reporting is enabled"
              echo "result=0" >> $GITHUB_OUTPUT
              exit 0
          fi
          
          # Check for security policy files
          SECURITY_FILES=(
              "SECURITY.md"
              "security.md"
              "docs/SECURITY.md"
              "docs/security.md"
              ".github/SECURITY.md"
              ".github/security.md"
          )
          
          PRIVATE_REPORTING_FOUND=0
          
          for FILE_PATH in "${SECURITY_FILES[@]}"; do
              if [ -f "$FILE_PATH" ]; then
                  # Read file content
                  CONTENT=$(cat "$FILE_PATH" | tr '[:upper:]' '[:lower:]')
                  
                  # Check for private reporting mechanisms
                  if [[ "$CONTENT" =~ "private" && "$CONTENT" =~ "report" ]] || 
                     [[ "$CONTENT" =~ "security@" ]] || 
                     [[ "$CONTENT" =~ "pgp" || "$CONTENT" =~ "gpg" || "$CONTENT" =~ "encrypt" ]] ||
                     [[ "$CONTENT" =~ "hackerone" || "$CONTENT" =~ "bugcrowd" || "$CONTENT" =~ "private form" ]]; then
                      echo "✅ Found private vulnerability reporting mechanism in $FILE_PATH"
                      PRIVATE_REPORTING_FOUND=1
                      break
                  fi
              fi
          done
          
          # Report findings
          if [ $PRIVATE_REPORTING_FOUND -eq 0 ]; then
              echo "❌ No private vulnerability reporting mechanism found"
              echo "result=1" >> $GITHUB_OUTPUT
              exit 1
          else
              echo "result=0" >> $GITHUB_OUTPUT
              exit 0
          fi
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate attestation for VM-03
        run: |
          RESULT=${{ steps.vm-03-check.outputs.result }}
          RESULT_TEXT=$([ "$RESULT" == "0" ] && echo "pass" || echo "fail")
          
          cat > attestations/osps-vm-03-attestation.json << EOF
          {
            "subject": {
              "name": "OSPS-VM-03",
              "digest": {
                "sha256": "${{ github.sha }}"
              }
            },
            "predicate": {
              "type": "https://github.com/osps/attestation/v1",
              "control": "OSPS-VM-03",
              "title": "The project MUST provide a means for reporting security vulnerabilities privately to the security contacts within the project.",
              "result": "$RESULT_TEXT",
              "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
              "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
          }
          EOF
        shell: bash
      
      - name: Upload attestations
        uses: actions/upload-artifact@v3
        with:
          name: osps-vm-attestations
          path: attestations/
          retention-days: 90